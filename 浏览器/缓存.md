# 浏览器缓存

浏览器中的缓存作用分为两种情况

* 需要发送http请求
* 不需要发送http请求

## 强缓存

首先检查强缓存，这个阶段不需要发送http请求，其通过相应字段来进行。

`HTTP/1.0`时期使用**Expires**，即过期时间，存在于服务端返回的响应头中，告诉浏览器过期时间之前可以直接从缓存里面获取数据，无需再次请求。（坑就是服务器时间和浏览器时间可能不一致，所以被抛弃）

```javascript
// 例如
Expires: Wed, 22 Nov 2019 08:41:00 GMT
//表示在2019年11月22日8点41分过期
```

`HTTP/1.1`时期使用**Cache-Control**，他不采用具体时间点，而是采用过期时长来控制缓存，对应字段为**max-age**。

```javascript
//例如
Cache-Control:max-age=3600
//表示服务器响应之后3600秒内可以直接使用缓存
```

> 当然还有：
>
> **public**: 客户端和代理服务器都可以缓存
>
> **private**： 这种情况就是只有浏览器能缓存了，中间的代理服务器不能缓存。
>
> **no-cache**: 跳过当前的强缓存，发送HTTP请求，即直接进入`协商缓存阶段`。
>
> **no-store**：非常粗暴，不进行任何形式的缓存。
>
> **s-maxage**：这和`max-age`长得比较像，但是区别在于s-maxage是针对代理服务器的缓存时间。
>
> 值得注意的是，当**Expires**和**Cache-Control**同时存在的时候，**Cache-Control**会优先考虑。
>

## 协商缓存

当`强缓存`时间超时，失效后，浏览器在请求头中携带相应的`缓存tag`来向服务器发请求，由服务器根据这个tag，来决定是否使用缓存，这就是**协商缓存**

**缓存tag**分为两种：`Last-Modified`和`ETag`。



> **Last-Modified**：即最后修改的时间。
>
> * 在浏览器第一次给服务器发送请求后，服务器会在响应头中加上这个字段。
> * 浏览器如果再次请求，会在请求头上携带`If-Modified-Since`字段，这个字段的值就是服务器传来的最后修改时间。
> * 服务器拿到请求头中的`If-Modified-Since`的自断后，会和服务器中`该资源的最后修改时间`做对比：
>   * 如果请求头中这个值小于最后修改时间，说明服务器里内容更新了，则返回新的资源，跟常规的HTTP请求响应流程一样。
>   * 否则返回304，告诉浏览器直接用缓存。
>
> 
>
> **ETag**：是服务器根据当前文件的内容，给文件生成的唯一标识，只要里面的内容有改动，这个值就会变。
>
> * 服务器通过`响应头`把这个值给浏览器。
>
> * 浏览器在下次请求时，将这个值作为`If-None-Match`这个字段的内容，并放到请求头中发给服务器。
> * 服务器收到`If-None-Match`后，会跟服务器上该资源的**ETag**进行对比：
>   * 如果不一样，说明要更新了。返回新的资源，跟常规的HTTP流程一样。
>   * 否则返回304，告诉浏览器直接用缓存。
>
> 
>
> **Last-Modified 和 ETag 的比较**
>
> * 在精度上，**ETag**优于**Last-Modified**，主要体现在两种情况上：
>   * 编辑了资源文件，但文件内容没有更改，ETag不变而Last-Modified会变化
>   * Last-Modified能够感知的单位时间是秒，如果文件在1s内改变了很多次，那么这时候就不精准了
> * 在性能上，**Last-Modified**优于**ETag**。因为Last-Modified仅仅是记录一个时间点，而ETag需要根据文件内容生成哈希值
>
> 
>
> 不过在两种都支持的情况下，服务器会优先考虑**ETag**

## 缓存位置

浏览器中的缓存位置一共有四种，查找顺序按优先级从高到低分别是：

* Service Worker
  * 是运行在浏览器背后的独立线程，一般可以用来实现缓存功能。使用 Service Worker的话，传输协议必须为 HTTPS。因为 Service Worker 中涉及到请求拦截，所以必须使用 HTTPS 协议来保障安全。Service Worker 的缓存与浏览器其他内建的缓存机制不同，它可以让我们自由控制缓存哪些文件、如何匹配缓存、如何读取缓存，并且缓存是持续性的。
* Memory Cache
  * 内存中的缓存，主要包含的是当前中页面中已经抓取到的资源，例如页面上已经下载的样式、脚本、图片等。读取内存中的数据肯定比磁盘快，内存缓存虽然读取高效，可是缓存持续性很短，会随着进程的释放而释放。一旦我们关闭 Tab 页面，内存中的缓存也就被释放了。
* Disk Cache
  * 就是存储在磁盘中的缓存，从存取效率上讲是比内存缓存慢的，但是他的优势在于存储容量和存储时长。
* Push Cache
  * Push Cache（推送缓存）是 HTTP/2 中的内容，当以上三种缓存都没有命中时，它才会被使用。它只在会话（Session）中存在，一旦会话结束就被释放，并且缓存时间也很短暂，在Chrome浏览器中只有5分钟左右，同时它也并非严格执行HTTP头中的缓存指令。

> 对于**Memory Cache**和**Disk Cache**，应该怎么选？
>
> - 比较大的JS、CSS文件会直接被丢进磁盘，反之丢进内存
> - 内存使用率比较高的时候，文件优先进入磁盘

## 总结

对于浏览器的缓存机制，大致为：

* 通过`Cache-Control`判断强缓存是否可用
  * 如果可用，直接使用
  * 否则进入协商缓存，发送HTTP请求。服务器根据请求头中的`If-Modified-Since`或者`If-None-Match`字段检查资源是否更新
    * 如果更新，返回资源和200状态码
    * 否则返回304，告诉浏览器直接从缓存获取资源
