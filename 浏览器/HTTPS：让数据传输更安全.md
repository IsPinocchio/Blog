# HTTPS：让数据传输更安全

HTTP是明文传输的，因此在传输过程的每一个环节，数据都有可能被中间人窃取和篡改。我们称之为**中间人攻击**。

### 一. 在HTTP协议栈中引入安全层

鉴于HTTP的明文传输使得传输过程毫无安全性可言，这制约了网上购物、在线转账等一系列应用场景。于是引入了**加密方案**。

![https](https://user-images.githubusercontent.com/61226624/132232826-b60f427c-a28f-489c-8adc-9af4c1e4999c.png)


可以看到HTTPS并非一个新的协议，而是中间加一个安全层。HTTPS先和安全层通信，然后安全层再和TCP层通信。

安全层主要两个职责：

* 对发起的HTTP请求的数据进行加密操作
* 对接收到的HTTP内容进行解密操作

（安全层不会影响到上层的HTTP协议，也不会影响到下层的TCP/IP协议）

### 二. 简单到复杂的HTTPS协议过程

先来了解几个定义：

**加密套件：**加密的方法

**加密条件列表**：浏览器能支持的多种加密方法列表

#### 2.1 使用对称加密

**对称加密**是指加密和解密都使用的是相同的秘钥。

![对称加密](https://user-images.githubusercontent.com/61226624/132232858-48af0cf3-769f-419c-9e23-d211f654e3b6.png)

* 在HTTPS发送数据之前，浏览器和服务器之间需要协商加密方式和秘钥。上图红色协商加密解密的过程就是HTTPS建立安全连接的过程。
* 为了让加密的秘钥更难以破解，我们让服务器和客户端同时决定秘钥并发给对方。
* 当浏览器和服务端有相同的client-random和service-random后，他们再使用相同的方法将二者混合起来生成一个秘钥master secret，有了这个秘钥和加密套件之后，双方就可以进行数据的加密传输了。

**缺点：**

因为client-random和service-random是明文传输的，这意味着黑客也可以拿到协商的加密套件的双方的随机数，然后利用这些可以合成秘钥来伪造和篡改数据。



#### 2.2 使用非对称加密

非对称加密算法有A、B想把秘钥。如果使用A秘钥来加密，那么只能用B秘钥来解密；反过来，用B加密，就得用A来解密。

在HTTPS中，服务器会将其中一个秘钥通过明文的形式发送给浏览器，这把秘钥就是**公钥**，服务器自己留下的秘钥是**私钥**。

（顾名思义，公钥是每个人都能获取得到的，私钥只能服务器才知道，不对任何人公开）

![非对称加密](https://user-images.githubusercontent.com/61226624/132232874-2510095d-442a-4794-be24-ed3669d56fb8.png)

**流程：**

* 协商加密方式：浏览器发送加密套件列表给服务器
* 服务器选择一个加密套件，将加密套件和公钥一起发送给浏览器
* 浏览器和服务器确认

*这样浏览器就有了公钥，再向服务器发送数据时，黑客没有私钥解密就无法破解数据。*

**缺点：**

* 加解密效率降低，影响用户打开页面的速度
* 无法保证服务器发送给浏览器的数据安全。因为黑客是可以在服务器发送公钥给浏览器时截获的。

#### 2.3 对称加密和非对称加密搭配使用

基于上述缺点，最终选择一个完美方案：**在传输数据阶段使用对称加密，但是对称加密的秘钥采用非对称加密来传输**。

![混合加密](https://user-images.githubusercontent.com/61226624/132232884-e9e1c1de-099e-425d-90fd-baf8909a50a4.png)

**流程：**

* 浏览器向服务器发送对称加密列表、非对称加密列表和随机数client-random。
* 服务器保存随机数client-random，选择对称加密和非对称加密的套件。生成随机数service-random。向浏览器发送选择的加密套件、service-random和公钥。
* 浏览器保存公钥后，利用client-random和service-random计算出一个pre-master，然后利用公钥对pre-master加密，发送给服务器。
* 服务器拿出私钥解密出pre-master数据，并返回确认

到此为止，服务器和浏览器就有了共同的client-random、service-random和pre-master，然后服务器和浏览器会使用这三组随机数生成对称秘钥，因为服务器和浏览器使用同一套方法来生成秘钥，所以最终生成的秘钥也是相同的。

（疑惑？？？ 黑客不也可以解惑client-random和service-random吗，那黑客不能生成pre-master吗？？？可能pre-master不是单单靠那两个生成的吧）

#### 2.4 添加数字证书

上述混合加密中，如果黑客通过DNS劫持将目的IP地址替换成了黑客的IP地址，那么我们访问的就是黑客的服务器了，黑客就可以在自己的服务器上实现公钥和私钥。

所以我们还需要服务器向浏览器证明 “我是正确的服务器”。

为了证明服务器的身份，需要一个权威机构颁发这个证书，这个权威机构叫**CA**（Certificate Authority），颁发的证书就成为**数字证书**（Digital Certificate）



对于浏览器来说，数字证书有两个作用：

* 通过数字证书向浏览器证明服务器的身份
* 数字证书里面包含了服务器公钥

![完整HTTPS请求流程](https://user-images.githubusercontent.com/61226624/132232908-049f2e6d-d1e3-4650-8d6b-c1d00182e45b.png)

相较于混合加密，主要有两点改变：

* 服务器没有直接返回公钥给浏览器，而是返回了数字证书。数字证书里包含公钥。
* 浏览器端多了一个证书验证操作，验证了证书之后，才继续后续流程。这样黑客服务器就无法欺骗用户了。

**如何申请数字证书**

* 开发团队需要准备一套私钥和公钥，私钥留着自己使用
* 开发团队向CA提交公钥、公司、站点等信息并等待认证（收费）
* CA通过线上、线下等多种渠道验证开发团队提供的信息真实性
* 信息审核通过，CA就会签发数字证书，包含了公钥、组织信息、CA信息、有效时间、证书序列号等。这些都是明文的，同时包含一个CA生成的签名。

数字签名： CA 使用**Hash 函数**来计算极客时间提交的明文信息，并得出**信息摘要**；然后 CA 再使用它的私钥对信息摘要进行加密，**加密后的密文就是 CA 颁给极客时间的数字签名**。



**浏览器如何验证数字证书**

* 浏览器读取证书中相关的明文信息，采用CA签名时相同的Hash函数来计算并得到**信息摘要A**
* 利用对应的CA的公钥解密签名数据，得到**信息摘要B**
* 对比A和B，如果一致，则可以确认证书是合法的。
* 但可能这个CA比较小众，浏览器不知道要不要信任它。浏览器会继续查找给这个CA颁发证书的CA，直到浏览器内置的顶级CA。



